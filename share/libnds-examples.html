<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="keywords" content="Sidonie Bouthors, cooking, programming">
        <meta name="description" content="Personal website of Sidonie Bouthors with recipes and projects">
        <meta name="author" content="Sidonie Bouthors">

        <title>LibNDS Examples</title>

        <link href="styles/share.css" rel="stylesheet" type="text/css" media="all">
        
        <link rel="shortcut icon" href="img/share.ico">

        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" integrity="sha512-0aPQyyeZrWj9sCA46UlmWgKOP0mUipLQ6OZXu8l4IcAmD2u31EPEy9VcIMvl7SoAaKe8bLXZhYoMaE/in+gcgA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">
        
        <meta property="og:title" content="Sidonie's Share">
        <meta property="og:description" content="A place where I share useful stuff">
        <meta property="og:image" content="https://sidonie.me/img/share-image.jpg">
        <meta property="og:image:width" content="1200">
        <meta property="og:image:height" content="630">
        <meta property="og:url" content="sidonie.me/share">
    </head>    
    <body>

    <div id="container">
    <main>

    <nav class="breadcrumb"><ol>
    <li><a href="./index.html">Share</a></li>
    <li>LibNDS Examples</li>
    </ol></nav>

    <p class="updated">Last updated on <time datetime="2023-11-20">Monday, November 20, 2023</time></p>

    <h1><a href="#general" id="general">LibNDS Examples</a></h1>

    <div class="note">
        <p>These examples are adapted from the content of EPFL's
            <a target="_blank" href=https://edu.epfl.ch/coursebook/en/microprogrammed-embedded-systems-EE-310>EE-310 Course</a>.
            For more details or advanced documentation, check out the official <a target="_blank" href="https://libnds.devkitpro.org/">LibNDS Documentation</a>.
        </p>
    </div>

    <h2><a href="#main-rotoscale" id="main-rotoscale">Rotoscale (Main Engine)</a></h2>

    <pre><code class="language-c">// 1. VRAM Configuration for MAIN engine
VRAM_A_CR = VRAM_ENABLE | VRAM_A_MAIN_BG;

// 2. Main engine configuration in rotoscale mode
REG_DISPCNT = MODE_5_2D | DISPLAY_BG2_ACTIVE;

// 3. Configure the background
BGCTRL[2] = BG_BMP_BASE(0) | BgSize_B8_256x256;

// 4. Copy bitmap and palette generated by grit
dmaCopy(logoBitmap, BG_BMP_RAM(0), logoBitmapLen);
dmaCopy(logoPal, BG_PALETTE, logoPalLen);

// Uncomment this for including the 
// Affine Marix Transformation
//	bgTransform[2]->xdx = 1*256;
//	bgTransform[2]->ydx = 0*256;
//	bgTransform[2]->xdy = 0*256;
//	bgTransform[2]->ydy = 1*256;
//	bgTransform[2]->dx = 0*256;
//	bgTransform[2]->dy = 0*256;

// Uncomment this for including the 
// Affine Marix Transformation (Native install only!)
bgTransform[2]->hdx = 1*256;
bgTransform[2]->vdx = 0*256;
bgTransform[2]->hdy = 0*256;
bgTransform[2]->vdy = 1*256;
bgTransform[2]->dx = 0*256;
bgTransform[2]->dy = 0*256;</code></pre>

    <h2><a href="#sub-tiled" id="sub-tiled">Tiled (Sub Engine)</a></h2>

    <pre><code class="language-c">// 1. VRAM configuration for SUB engine
VRAM_C_CR = VRAM_ENABLE | VRAM_C_SUB_BG;

// 2. SUB engine configuration in tiled mode
REG_DISPCNT_SUB = MODE_0_2D | DISPLAY_BG0_ACTIVE;

// 3. Configure the background
BGCTRL_SUB[0] = BG_32x32 | BG_COLOR_256 
    | BG_MAP_BASE(0) | BG_TILE_BASE(1);

// 4. Copy the 4 tiles to the tile base
dmaCopy(RedTile, BG_TILE_RAM_SUB(1), 64);
dmaCopy(BlueTile, BG_TILE_RAM_SUB(1) + 32, 64);
dmaCopy(GreenTile, BG_TILE_RAM_SUB(1) + 32*2, 64);
dmaCopy(WhiteTile, BG_TILE_RAM_SUB(1) + 32*3, 64);
dmaCopy(BlackTile, BG_TILE_RAM_SUB(1) + 32*4, 64);

// 5. Initialize the palette (5 components)
BG_PALETTE_SUB[0] = ARGB16(1, 31, 0, 0);
BG_PALETTE_SUB[1] = ARGB16(1, 0, 0, 31);
BG_PALETTE_SUB[2] = ARGB16(1, 0, 31, 0);
BG_PALETTE_SUB[3] = ARGB16(1, 31, 31, 31);
BG_PALETTE_SUB[4] = ARGB16(1, 0, 0, 0);

// 6. Generate the map
for (int i = 0; i &lt; 24; i++) {
    for (int j = 0; j &lt; 32; j+=2) {
        if (i % 2 == 0) {
            BG_MAP_RAM_SUB(0)[i*32+j] = 3;
            BG_MAP_RAM_SUB(0)[i*32+j+1] = 4;
        } else {
            BG_MAP_RAM_SUB(0)[i*32+j] = 4;
            BG_MAP_RAM_SUB(0)[i*32+j+1] = 3;
        }
    }
}</code></pre>

    <h2><a href="#timer" id="timer">Timer</a></h2>

    <pre><code class="language-c">// 1. Configure the timer to raise an interrupt 
//    10 times per second
int frequency = 20;
TIMER0_CR = TIMER_DIV_64 | TIMER_ENABLE | TIMER_IRQ_REQ;
TIMER0_DATA = TIMER_FREQ_64(frequency);

// 2. Associate the implemented ISR to 
//    the Timer Interrupt Line
irqSet(IRQ_TIMER0, &timer_ISR);

// 3. Enable the timer interrupt
irqEnable(IRQ_TIMER0);</code></pre>


    <h2><a href="#graphics-sprites" id="graphics-sprites">Sprites</a></h2>

    <h3><a href="#graphics-sprites-main" id="graphics-sprites-main">Main</a></h3>
    <pre><code class="language-c">
#include &lt;nds.h&gt;
#include &lt;stdio.h&gt;
#include "field.h"
#include "ball.h"

#define SCREEN_WIDTH	256
#define	SCREEN_HEIGHT	192

#define	SPRITE_WIDTH	32
#define	SPRITE_HEIGHT	32

//Pointer to the graphic buffer where to store the sprite
u16* gfx;

void configureBG0() {
    //Activate and configure VRAM bank to work 
    //in background mode
    VRAM_A_CR = VRAM_ENABLE | VRAM_A_MAIN_BG;

    //BG0 configuration for the background
    BGCTRL[0] = BG_COLOR_256 | BG_MAP_BASE(0) 
    | BG_TILE_BASE(1) | BG_32x32;

    //Copy data to display background 
    //(tiles, palette and map)
    dmaCopy(fieldPal, BG_PALETTE, fieldPalLen);
	dmaCopy(fieldTiles, BG_TILE_RAM(1), fieldTilesLen);
	dmaCopy(fieldMap, BG_MAP_RAM(0), fieldMapLen);
}


void configureSprites() {
    //Set up memory bank to work in sprite mode 
    //(offset since we are using VRAM A for backgrounds)
    VRAM_B_CR = VRAM_ENABLE | VRAM_B_MAIN_SPRITE;

    //Initialize sprite manager and the engine
    oamInit(&oamMain, SpriteMapping_1D_32, false);

    //Allocate space for the graphic to show in the sprite
    gfx = oamAllocateGfx(&oamMain, 
        SpriteSize_32x32, SpriteColorFormat_256Color);

    //Copy data for the graphic (palette and bitmap)
    swiCopy(ballPal, SPRITE_PALETTE, ballPalLen/2);
    swiCopy(ballTiles, gfx, ballTilesLen/2);
}

int main(void) {

    //MAIN engine
    REG_DISPCNT = MODE_0_2D | DISPLAY_BG0_ACTIVE;

    //Configure and fill BG0
    configureBG0();

    //Configure sprites and fill graphics
    configureSprites();

    //Position
    int x = 0, y = 0, keys;
    while(1){
        //Read held keys
        scanKeys();
        keys = keysHeld();

        //Modify position of the sprite accordingly
        if((keys & KEY_RIGHT) 
            && (x &lt; (SCREEN_WIDTH - SPRITE_WIDTH))) x+=2;
        if((keys & KEY_DOWN) 
            && (y &lt; (SCREEN_HEIGHT - SPRITE_HEIGHT))) y+=2;
        if((keys & KEY_LEFT) 
            && (x  > 0)) x-=2;
        if((keys & KEY_UP) 
            && (y  > 0)) y-=2;

        oamSet(&oamMain,    // oam handler
            0,              // Number of sprite
            x, y,           // Coordinates
            0,              // Priority
            0,              // Palette to use
            SpriteSize_32x32,           // Sprite size
            SpriteColorFormat_256Color,	// Color format
            gfx,            // Loaded graphic to display
            -1,             // Affine rotation (-1 none)
            false,          // Double size if rotating
            false,          // Hide this sprite
            false, false,   // Horizontal or vertical flip
            false           // Mosaic
            );
        swiWaitForVBlank();
        //Update the sprites
        oamUpdate(&oamMain);
    }
}
        </code></pre>

        <h3><a href="#graphics-sprites-grit" id="graphics-sprites-grit">Grit</a></h3>
        <p>field.grit</p>
        <pre><code>-g<br>-gt<br>-gB8<br>-m<br>-p (unnecessary)</code></pre>
        <p>ball.grit</p>
        <pre><code>-g<br>-gt<br>-gB8<br>-gT00FF00<br>-p (unnecessary)</code></pre>

    <h2><a href="#controls" id="controls">Controls</a></h2>

    <h3><a href="#controls-main" id="controls-main">Complex (Interrupts & Polling)</a></h3>
    <pre><code class="language-c">
#include &lt;nds.h&gt;
#include &lt;stdio.h&gt;

//Keys ISR
void keysISR()
{
    //Read the kEYINPUT register
    u16 keys = ~(REG_KEYINPUT);

    //Identify which key triggered the interrupt and 
    //print it in the console
    if(keys & KEY_UP)
        printf("Key UP pressed (ISR)\n");
    if(keys & KEY_DOWN)
        printf("Key DOWN pressed (ISR)\n");
    if(keys & KEY_RIGHT)
        printf("Key RIGHT pressed (ISR)\n");
    if(keys & KEY_LEFT)
        printf("Key LEFT pressed (ISR)\n");
}

//-------------------------------------
int main(void) {
//-------------------------------------

    //Initialize the console
    consoleDemoInit();
    scanKeys();

    /*************
    * Exercise 2
    *************/
    //Initialize the interrupt system
    irqInit();
    /*Configure the keys to throw an interrupt 
    with the keys UP, DOWN, LEFT or RIGHT*/
    REG_KEYCNT = KEY_LEFT | KEY_RIGHT | KEY_DOWN 
        | KEY_UP | 1&lt;&lt;14;
    //Set the ISR to the IRQ line and enable the IRQ line
    irqSet(IRQ_KEYS, &keysISR);
    irqEnable(IRQ_KEYS);
    //Do not forget to enable the IRQ line for the VBLANK
    irqEnable(IRQ_VBLANK);

    /********************/

    //The main infinite loop
    while(1) {
        /*************
        * Exercise 1
        *************/
        //Scan the keys
        scanKeys();
        //Identify which key was pressed 
        //and print it in the console
        u16 keys = keysDown();
        if(keys & KEY_A)
            printf("Key A pressed \n");
        if(keys & KEY_B)
            printf("Key B pressed \n");
        if(keys & KEY_X)
            printf("Key X pressed \n");
        if(keys & KEY_Y)
            printf("Key Y pressed \n");

        /*******************/

        /*************
        * Exercise 3 (comment exercise 2)
        *************/
        //Declare a touchPosition variable
        touchPosition touch;
        //Read the touchscreen
        touchRead(&touch);
        //Identify a valid touched coordinates 
        //and print them
        if(touch.px | touch.py)
            printf("Touch in (%i,%i)\n", 
                touch.px, touch.py);

        /**************/

        swiWaitForVBlank();
    }
}</code></pre>

    <h3><a href="#controls-other" id="controls-other">Simple (Polling)</a></h3>
    <pre><code class="language-c">while(1){

    // 1. Scan the keypad
    scanKeys();

    // 2. Obtain the pressed keys
    uint32 keys = keysDown();

    // 3. Check if the pressed key is the correct one 
    //    and increase/decrease the frequency accordingly
    if (keys & KEY_UP) {
        frequency *= 2;
    }
    if (keys & KEY_DOWN) {
        frequency /= 2;
    }
    TIMER0_DATA = TIMER_FREQ_64(frequency);

    // 4. Read the touchscreen position
    touchPosition* pos;
    touchRead(pos);

    // 5. If touched, set the new color
    if (pos->px > 0 && pos->py > 0) {
        current_color = (current_color + 1) % 3;
    }

    swiWaitForVBlank();
}</code></pre>
        
    </main>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js" integrity="sha512-rdhY3cbXURo13l/WU9VlaRyaIYeJ/KBakckXIvJNAQde8DgpOmE+eZf7ha4vdqVjTtwQt69bD2wH2LXob/LB7Q==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/scala.min.js" integrity="sha512-F7HBSjTYDsAreqced8cggvF5AuB+j2TXktnLYpCrpWF2fhQJJCc5KimR3LYLs0AppTBecbPN9M9Hjf8yC2WstA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
    <script src="scripts.js"></script>

</body>
    
</html>